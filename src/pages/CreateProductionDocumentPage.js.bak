import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import { saveAudit, saveSchedule } from '../services/api';
import { bus } from '../utils/eventBus';
import InfoCard from '../components/InfoCard';
import ChangeHistoryDialog from '../components/ChangeHistoryDialog';
import UnifiedScheduleModal from '../components/UnifiedScheduleModal';
import {
  Box, Avatar, Grid, Paper, Typography, Button, Tabs, Tab, Divider, Tooltip,
  Table, TableContainer, TableHead, TableRow, TableCell, TableBody,
  Card, CardContent, CardActions, Dialog, DialogTitle, DialogContent, DialogActions,
  TextField, IconButton, Chip, InputLabel, Select, FormControl, MenuItem,
  ToggleButtonGroup, ToggleButton, Snackbar, Alert
} from '@mui/material';
import { useTheme, alpha } from '@mui/material/styles';
import BakeryDiningIcon from '@mui/icons-material/BakeryDining';
import SetMealIcon from '@mui/icons-material/SetMeal';
import SoupKitchenIcon from '@mui/icons-material/SoupKitchen';
import CalendarMonthIcon from '@mui/icons-material/CalendarMonth';
import FactCheckIcon from '@mui/icons-material/FactCheck';
import MenuBookIcon from '@mui/icons-material/MenuBook'; 
import PeopleIcon from '@mui/icons-material/People';
import AddIcon from '@mui/icons-material/Add';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import PrintIcon from '@mui/icons-material/Print';
import FileDownloadIcon from '@mui/icons-material/FileDownload';
import ListIcon from '@mui/icons-material/List';
import ViewModuleIcon from '@mui/icons-material/ViewModule';
import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import timeGridPlugin from '@fullcalendar/timegrid';
import interactionPlugin from '@fullcalendar/interaction';
import { fetchSchedules, fetchAudits, fetchRecipes, fetchHandlers } from '../services/api'; 
import departments from '../data/department_table.json';
import ExportScheduleModal from '../components/ExportScheduleModal';
import PrintDocumentModal from '../components/PrintDocumentModal';

// Map JSON icon key to component
const iconMap = { SetMealIcon, SoupKitchenIcon, BakeryDiningIcon };

const CreateProductionDocumentPage = () => {
  const { department } = useParams();
  const theme = useTheme();
  const calendarRef = useRef(null);
  
  // Wrap deptObj in useMemo to prevent recreation on every render
  const deptObj = useMemo(() => {
    return departments.find(d => d.department_code === department) || {};
  }, [department]);

  const accentColor = deptObj.color || theme.palette.primary.main; 
  const departmentDisplayName = deptObj.department || 'Department';
  const IconComponent = iconMap[deptObj.icon]; 

  const [schedules, setSchedules] = useState([]);
  const [audits, setAudits] = useState([]);
  const [recipes, setRecipes] = useState([]);
  const [handlers, setHandlers] = useState([]);
  const [departmentRecipesCount, setDepartmentRecipesCount] = useState(0); 
  const [departmentStaffCount, setDepartmentStaffCount] = useState(0);
  const [activeTab, setActiveTab] = useState(0);
  const [calendarEvents, setCalendarEvents] = useState([]); // States for Schedule tab
  const [currentEventInfo, setCurrentEventInfo] = useState(null);
  const [currentSlotInfo, setCurrentSlotInfo] = useState(null);
  const [notification, setNotification] = useState({
    open: false,
    message: '',
    severity: 'info'
  });
  
  // States for Production Documents tab
  const [exportModalOpen, setExportModalOpen] = useState(false);
  const [printModalOpen, setPrintModalOpen] = useState(false);
  const [editModalOpen, setEditModalOpen] = useState(false);
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [selectedSchedule, setSelectedSchedule] = useState(null);
  const [selectedItem, setSelectedItem] = useState(null);
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [filteredSchedules, setFilteredSchedules] = useState([]);
  const [documentView, setDocumentView] = useState('list'); // 'list', 'card', or 'calendar'
  const [historyDialogOpen, setHistoryDialogOpen] = useState(false);
  const [selectedHistoryItem, setSelectedHistoryItem] = useState(null);
  const [viewDetailsOpen, setViewDetailsOpen] = useState(false);
  const [dayViewOpen, setDayViewOpen] = useState(false);
  const [dayEventsData, setDayEventsData] = useState(null);
  
  // Unified modal state
  const [unifiedModalOpen, setUnifiedModalOpen] = useState(false);
  const [unifiedModalMode, setUnifiedModalMode] = useState('schedule'); // 'schedule' or 'production'
  const [unifiedModalItem, setUnifiedModalItem] = useState(null);

  // Function to load data from API - wrapped in useCallback to prevent recreation on every render
  const loadData = useCallback(async () => {
    try {
      // Add a timestamp to prevent browser caching
      const timestamp = new Date().getTime();
      console.log(`Loading data for CreateProductionDocumentPage... (${timestamp})`);
      
      // Make sure we have a valid department before fetching
      if (!department || !deptObj.department) {
        console.warn('Cannot load data: missing department information');
        return;
      }
      
      const [sch, aud, recipesData, handlersData] = await Promise.all([
        fetchSchedules(department),
        fetchAudits(department),
        fetchRecipes(deptObj.department),      
        fetchHandlers(deptObj.department)      
      ]);
      
      // If handlers are empty, try using the handlers array from the department object
      const finalHandlers = handlersData && handlersData.length > 0 
        ? handlersData 
        : (deptObj.handlers ? deptObj.handlers.map(name => ({ name, id: name })) : []);
      
      setSchedules(sch || []);
      setAudits(aud || []);
      setRecipes(recipesData || []);
      setHandlers(finalHandlers);
      setDepartmentRecipesCount(recipesData ? recipesData.length : 0);
      setDepartmentStaffCount(finalHandlers ? finalHandlers.length : 0);
      
      console.log(`Data loaded successfully (${timestamp})`);
    } catch (error) {
      console.error('Error loading data for CreateProductionDocumentPage:', error);
    }
  }, [department, deptObj]);
  
  // This useEffect is only for loading data when department changes
  useEffect(() => {
    if (department) {
      console.log('Department changed, loading data...');
      loadData();
    }
  }, [department, loadData]);

  // Separate useEffect for initializing calendar events when data changes
  useEffect(() => {
    const initializeCalendarEvents = () => {
      try {
        // Create calendar events from schedules
        const events = [];
        
        schedules.forEach(schedule => {
          if (schedule.items && Array.isArray(schedule.items)) {
            schedule.items.forEach((item, idx) => {
              // Find recipe details
              const recipe = recipes.find(r => r.product_code === item.recipeCode) || {};
              const title = `${item.productDescription || recipe.description || item.recipeCode} (${item.plannedQty})`;
              
              // Set the event color based on status
              let eventColor = accentColor;
              if (item.status === 'planned') eventColor = theme.palette.info.main;
              else if (item.status === 'scheduled') eventColor = theme.palette.warning.main;
              else if (item.status === 'completed') eventColor = theme.palette.success.main;
              else if (item.status === 'cancelled') eventColor = theme.palette.error.main;
              
              // Parse date and times
              const itemDate = new Date(item.date);
              
              // Parse start time
              const [startHours, startMinutes] = (item.startTime || '08:00').split(':').map(Number);
              const startDate = new Date(itemDate);
              startDate.setHours(startHours, startMinutes, 0);
              
              // Parse end time
              const [endHours, endMinutes] = (item.endTime || '09:00').split(':').map(Number);
              const endDate = new Date(itemDate);
              endDate.setHours(endHours, endMinutes, 0);
              
              // Create event object for FullCalendar with proper time information
              events.push({
                id: item.id,
                title: title,
                start: startDate,
                end: endDate,
                backgroundColor: eventColor,
                borderColor: eventColor,
                textColor: theme.palette.getContrastText(eventColor),
                extendedProps: {
                  scheduleId: schedule.id,
                  itemIndex: idx,
                  status: item.status,
                  plannedQty: item.plannedQty,
                  recipeCode: item.recipeCode,
                  handlerName: item.handlerName
                }
              });
            });
          }
        });
        
        setCalendarEvents(events);
      } catch (error) {
        console.error("Failed to initialize calendar events:", error);
        setCalendarEvents([]);
      }
    };
    
    // Initialize calendar events when schedules, recipes, or theme changes
    if (schedules.length > 0 && recipes.length > 0) {
      initializeCalendarEvents();
    }
  }, [schedules, recipes, accentColor, theme.palette]);
  
  const departmentIconContent = (() => {
    return IconComponent ? <IconComponent sx={{ fontSize: '2.5rem', mr: 1.5 }} /> : <Avatar sx={{ bgcolor: 'transparent', color: 'inherit', width: 40, height: 40, mr: 1.5, fontSize: '1.5rem' }}>{departmentDisplayName.charAt(0)}</Avatar>;
  })();
  
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
    
    // If switching to Production Documents tab, initialize with current week
    if (newValue === 1 && !startDate) {
      const today = new Date();
      const startOfWeek = new Date(today);
      startOfWeek.setDate(today.getDate() - today.getDay()); // Sunday
      const endOfWeek = new Date(today);
      endOfWeek.setDate(today.getDate() + (6 - today.getDay())); // Saturday
      
      setStartDate(startOfWeek.toISOString().substring(0, 10));
      setEndDate(endOfWeek.toISOString().substring(0, 10));
    }
  };
  
  const handleDateClick = (info) => {
    // Set current slot info regardless of tab
    setCurrentSlotInfo({
      date: info.dateStr
    });
    
    if (activeTab === 1) {
      // In Production Documents tab, always allow scheduling
      setUnifiedModalMode('schedule');
      setUnifiedModalItem(null);
      setUnifiedModalOpen(true);
    } else {
      // In Production Schedule tab, behavior depends on the current view
      const calendarApi = info.view.calendar;
      const currentViewType = calendarApi.view.type;
      
      if (currentViewType === 'dayGridMonth') {
        // Month view: show view-only dialog for the day
        const dayEvents = calendarEvents.filter(event => {
          const eventDate = new Date(event.start);
          return eventDate.toISOString().split('T')[0] === info.dateStr;
        });
        
        if (dayEvents.length > 0) {
          // Show a day summary dialog
          setDayEventsData({
            date: info.dateStr,
            events: dayEvents
          });
          setDayViewOpen(true);
        } else {
          // No events for this day
          console.log('No events scheduled for this day');
        }
      } else {
        // Week/Day view: allow scheduling
        setUnifiedModalMode('schedule');
        setUnifiedModalItem(null);
        setUnifiedModalOpen(true);
      }
    }
  };
  
  const handleEventClick = (info) => {
    // Get the event details
    const eventInfo = info.event;
    // We don't need status here, so we're not destructuring it
    
    if (activeTab === 1) {
      // In Production Documents tab, always allow editing
      setCurrentEventInfo(eventInfo);
      setUnifiedModalMode('schedule');
      setUnifiedModalItem(null); // We'll use currentEventInfo instead
      setUnifiedModalOpen(true);
    } else {
      // In Production Schedule tab, behavior depends on the current view
      const calendarApi = info.view.calendar;
      const currentViewType = calendarApi.view.type;
      
      if (currentViewType === 'dayGridMonth') {
        // Month view: only show details in read-only mode
        setCurrentEventInfo(eventInfo);
        
        // Find the schedule and item for detailed view
        const { scheduleId, itemIndex } = eventInfo.extendedProps;
        const schedule = schedules.find(s => s.id === scheduleId);
        
        if (schedule && schedule.items && schedule.items[itemIndex]) {
          const item = schedule.items[itemIndex];
          setSelectedHistoryItem(item);
          
          // Show view-only details dialog
          setViewDetailsOpen(true);
        }
      } else {
        // Week/Day view: allow editing
        setCurrentEventInfo(eventInfo);
        setUnifiedModalMode('schedule');
        setUnifiedModalItem(null); // We'll use currentEventInfo instead
        setUnifiedModalOpen(true);
      }
    }
  };
  
  const handleViewHistory = (event, scheduleId, itemIndex) => {
    // Prevent the event from bubbling up to the calendar event click handler
    event.stopPropagation();
    
    // Find the schedule and item
    const schedule = schedules.find(s => s.id === scheduleId);
    if (schedule && schedule.items && schedule.items[itemIndex]) {
      const item = schedule.items[itemIndex];
      setSelectedHistoryItem(item);
      setHistoryDialogOpen(true);
      console.log('Viewing change history for item:', item);
    } else {
      console.error('Could not find schedule item for history view');
    }
  };
  
  // Handle time slot selection (drag over time slots)
  const handleSelectTimeSlot = (selectInfo) => {
    // Set current slot info regardless of tab
    setCurrentSlotInfo(selectInfo);
    
    if (activeTab === 1) {
      // In Production Documents tab, always allow scheduling
      setUnifiedModalMode('schedule');
      setUnifiedModalItem(null);
      setUnifiedModalOpen(true);
    } else {
      // In Production Schedule tab, behavior depends on the current view
      const calendarApi = selectInfo.view.calendar;
      const currentViewType = calendarApi.view.type;
      
      if (currentViewType === 'dayGridMonth') {
        // Month view: show view-only dialog for the day/time range
        const startDate = selectInfo.start;
        const endDate = selectInfo.end;
        
        // Find all events in this time range
        const rangeEvents = calendarEvents.filter(event => {
          const eventStart = new Date(event.start);
          return eventStart >= startDate && eventStart < endDate;
        });
        
        if (rangeEvents.length > 0) {
          // Show a time range summary dialog
          setDayEventsData({
            date: startDate.toISOString().split('T')[0],
            startTime: startDate.toTimeString().substring(0, 5),
            endTime: endDate.toTimeString().substring(0, 5),
            events: rangeEvents
          });
          setDayViewOpen(true);
        } else {
          // No events in this time range
          console.log('No events scheduled in this time range');
        }
      } else {
        // Week/Day view: allow scheduling
        setUnifiedModalMode('schedule');
        setUnifiedModalItem(null);
        setUnifiedModalOpen(true);
      }
    }
  };
  
  // Filter schedules based on date range
  useEffect(() => {
    if (startDate || endDate) {
      const filtered = schedules.filter(schedule => {
        if (startDate && endDate) {
          return schedule.weekStartDate >= startDate && schedule.weekStartDate <= endDate;
        } else if (startDate) {
          return schedule.weekStartDate >= startDate;
        } else if (endDate) {
          return schedule.weekStartDate <= endDate;
        }
        return true;
      });
      setFilteredSchedules(filtered);
    } else {
      setFilteredSchedules(schedules);
    }
  }, [schedules, startDate, endDate]);
  
  // Handle edit document
  const handleEditDocument = (schedule, item, index) => {
    setSelectedSchedule(schedule);
    setSelectedItem({ ...item, index });
    setEditModalOpen(true);
  };
  
  // Handle delete document
  const handleDeleteDocument = (schedule, item, index) => {
    setSelectedSchedule(schedule);
    setSelectedItem({ ...item, index });
    setDeleteConfirmOpen(true);
  };
  
  // Handle confirm delete
  const handleConfirmDelete = async () => {
    if (!selectedSchedule || selectedItem === null) return;
    
    try {
      // Create a copy of the schedule
      const updatedSchedule = { ...selectedSchedule };
      
      // Remove the item from the items array
      updatedSchedule.items = updatedSchedule.items.filter((_, idx) => idx !== selectedItem.index);
      
      // If there are no more items, delete the entire schedule
      if (updatedSchedule.items.length === 0) {
        // await deleteSchedule(department, selectedSchedule.id);
        setSchedules(schedules.filter(s => s.id !== selectedSchedule.id));
      } else {
        // Otherwise update the schedule with the item removed
        // const savedSchedule = await saveSchedule(department, updatedSchedule);
        setSchedules(schedules.map(s => s.id === selectedSchedule.id ? updatedSchedule : s));
      }
      
      // Update calendar events
      setCalendarEvents(calendarEvents.filter(event => 
        !(event.extendedProps.scheduleId === selectedSchedule.id && 
          event.extendedProps.itemIndex === selectedItem.index)
      ));
      
      setDeleteConfirmOpen(false);
      setSelectedSchedule(null);
      setSelectedItem(null);
    } catch (error) {
      console.error('Failed to delete document:', error);
    }
  };
  
  // Handle save edited document
  const handleSaveEdit = async (editedData) => {
    if (!selectedSchedule || selectedItem === null) return;
    
    try {
      // Create a copy of the schedule
      const updatedSchedule = { ...selectedSchedule };
      
      // Update the specific item
      updatedSchedule.items = [...updatedSchedule.items];
      updatedSchedule.items[selectedItem.index] = {
        ...updatedSchedule.items[selectedItem.index],
        ...editedData
      };
      
      // Save the updated schedule
      // const savedSchedule = await saveSchedule(department, updatedSchedule);
      setSchedules(schedules.map(s => s.id === selectedSchedule.id ? updatedSchedule : s));
      
      // Update calendar events
      const recipe = recipes.find(r => r.product_code === editedData.recipeCode);
      const [startHours, startMinutes] = editedData.startTime.split(':').map(Number);
      const [endHours, endMinutes] = editedData.endTime.split(':').map(Number);
      
      const startDate = new Date(selectedSchedule.weekStartDate);
      startDate.setHours(startHours, startMinutes, 0);
      
      const endDate = new Date(selectedSchedule.weekStartDate);
      endDate.setHours(endHours, endMinutes, 0);
      
      const updatedEvent = {
        id: `${selectedSchedule.id}-${selectedItem.index}`,
        title: `${recipe?.description || editedData.recipeCode} (${editedData.plannedQty})`,
        start: startDate,
        end: endDate,
        backgroundColor: accentColor,
        borderColor: accentColor,
        textColor: theme.palette.getContrastText(accentColor),
        extendedProps: {
          scheduleId: selectedSchedule.id,
          itemIndex: selectedItem.index,
          recipeCode: editedData.recipeCode,
          plannedQty: editedData.plannedQty,
          handlerName: editedData.handlerName
        }
      };
      
      setCalendarEvents(calendarEvents.map(event => 
        (event.extendedProps.scheduleId === selectedSchedule.id && 
         event.extendedProps.itemIndex === selectedItem.index) ? updatedEvent : event
      ));
      
      setEditModalOpen(false);
      setSelectedSchedule(null);
      setSelectedItem(null);
    } catch (error) {
      console.error('Failed to save edited document:', error);
    }
  };
  
  // Handle print documents
  // eslint-disable-next-line no-unused-vars
  const handlePrintDocuments = () => {
    setPrintModalOpen(true);
  };
  
  // Toggle document view (list/card)
  // eslint-disable-next-line no-unused-vars
  const toggleDocumentView = () => {
    setDocumentView(documentView === 'list' ? 'card' : 'list');
  };

  // Function to handle confirming a production from a schedule
  const handleConfirmSchedule = (schedule, itemIndex) => {
    if (schedule && schedule.items && schedule.items[itemIndex]) {
      const item = schedule.items[itemIndex];
      const scheduleItem = {
        ...item,
        scheduleId: schedule.id,
        itemIndex,
        date: schedule.weekStartDate,
        managerName: schedule.managerName,
        handlersNames: schedule.handlersNames,
        originalScheduleId: schedule.id
      };
      
      // Open the unified modal in production mode
      setUnifiedModalMode('production');
      setUnifiedModalItem(scheduleItem);
      setUnifiedModalOpen(true);
    }
  };

  // Note: handleConfirmProduction has been removed as it's no longer needed with the status-based workflow
  // All functionality is now handled by handleSaveTimeSlot based on the item's status
  
  // Function to save time slot for scheduling recipes with simplified status-based workflow
  const handleSaveTimeSlot = async (dataFromModal) => {
    try {
    console.log('Saving data with simplified status-based workflow:', dataFromModal);
    // Extract data from modal with support for status-based workflow
    const { 
      id, date, recipeCode, plannedQty, handlerName: itemHandler, startTime, endTime, managerName,
      status, changeHistory, productDescription,
      // Production-specific fields
      actualQty, qualityScore, notes, ingredientSuppliers, batchCodes,
      sellByDates, receivingDates, deviations, confirmationTimestamp
    } = dataFromModal;
    
    // We'll get the recipe when needed in the audit creation section

    // Create or update the day's schedule
    let daySchedule;
    let isNewScheduleDay = false;
    
    // Find if we already have a schedule for this day
    const dateObj = new Date(date);
    const weekStartDate = new Date(dateObj);
    weekStartDate.setDate(dateObj.getDate() - dateObj.getDay()); // Set to Sunday
    
    const formattedWeekStartDate = weekStartDate.toISOString().substring(0, 10);
    
    daySchedule = schedules.find(s => s.weekStartDate === formattedWeekStartDate && s.department === department);
    isNewScheduleDay = !daySchedule;
    
    if (isNewScheduleDay) {
      // Create a new schedule for this week
      daySchedule = {
        id: schedules.length + 1,
        weekStartDate: formattedWeekStartDate,
        department,
        managerName: deptObj.manager || 'Department Manager',
        handlersNames: [],
        items: []
      };
    }
    
    // Create a unique ID for the item if it's new
    const itemId = currentEventInfo ? 
      currentEventInfo.event.id : 
      `${date}-${recipeCode}-${Date.now()}`;
    
    // Create the new item with all the data
    const newItem = {
      id: itemId,
      recipeCode,
      plannedQty: Number(plannedQty),
      handlerName: itemHandler,
      startTime,
      endTime,
      date,
      status,
      productDescription
    };
    
    // If this is a completed production, add production-specific fields
    if (status === 'completed') {
      newItem.actualQty = Number(actualQty);
      newItem.qualityScore = Number(qualityScore);
      newItem.notes = notes;
      newItem.ingredientSuppliers = ingredientSuppliers;
      newItem.batchCodes = batchCodes;
      newItem.sellByDates = sellByDates;
      newItem.receivingDates = receivingDates;
      newItem.deviations = deviations || ['none'];
      newItem.confirmationTimestamp = new Date().toISOString();
    }
    
    // Check if this is an update to an existing item
    const existingItemIndex = currentEventInfo ? 
      daySchedule.items.findIndex(item => item.id === itemId) : -1;
    
    if (existingItemIndex !== -1) {
      // This is an update to an existing item
      const existingItem = daySchedule.items[existingItemIndex];
      
      // Track changes for history
      const changes = [];
      
      // Check for changes in status
      if (existingItem.status !== status) {
        changes.push({ field: 'status', oldValue: existingItem.status, newValue: status });
      }
      
      // Check for changes in plannedQty
      if (existingItem.plannedQty !== Number(plannedQty)) {
        changes.push({ field: 'plannedQty', oldValue: existingItem.plannedQty, newValue: Number(plannedQty) });
      }
      
      // Check for changes in handlerName
      if (existingItem.handlerName !== itemHandler) {
        changes.push({ field: 'handlerName', oldValue: existingItem.handlerName, newValue: itemHandler });
      }
      
      // Check for changes in startTime
      if (existingItem.startTime !== startTime) {
        changes.push({ field: 'startTime', oldValue: existingItem.startTime, newValue: startTime });
      }
      
      // Check for changes in endTime
      if (existingItem.endTime !== endTime) {
        changes.push({ field: 'endTime', oldValue: existingItem.endTime, newValue: endTime });
      }
      
      // If there are changes, add to history
      if (changes.length > 0) {
        // Initialize changeHistory if it doesn't exist
        if (!existingItem.changeHistory) {
          existingItem.changeHistory = [];
        }
        
        // Add the change record
        const changeRecord = {
          timestamp: new Date().toISOString(),
          changedBy: 'Current User', // This would come from auth context in a real app
          changes
        };
        
        // Add the change record to history
        newItem.changeHistory = [...existingItem.changeHistory, changeRecord];
      } else {
        // No changes, keep existing history
        newItem.changeHistory = existingItem.changeHistory || [];
      }
      
      // Update the item in the schedule
      daySchedule.items[existingItemIndex] = newItem;
    } else {
      // For new items, initialize change history
      newItem.changeHistory = [{
        timestamp: new Date().toISOString(),
        changedBy: 'Current User', // This would come from auth context in a real app
        changes: [{ field: 'created', oldValue: null, newValue: 'new item' }]
      }];
      
      // Add the new item to the schedule
      daySchedule.items.push(newItem);
    }
    
    // Check if we need to create an audit record for a completed assignment
    let auditCreated = false;
    let savedAudit = null;
    
    if (newItem.status === 'completed') {
      // Check if we already have an audit record for this item
      const existingAudit = audits.find(a => a.originalScheduleId === newItem.id);
      
      if (!existingAudit) {
        // Get the recipe and create a new audit record
        const recipe = recipes.find(r => r.product_code === recipeCode);
        const auditData = createAuditFromProductionData(newItem, recipe);
        
        try {
          // Save audit to API
          savedAudit = await saveAudit(department, auditData);
          console.log('Audit saved from completed production:', savedAudit);
          
          // Update local audits state
          setAudits(prevAudits => [...prevAudits, savedAudit || auditData]);
          
          // Notify other components
          bus.emit('new-audit', savedAudit || auditData);
          bus.emit('data-updated', { type: 'new-audit', data: savedAudit || auditData });
          
          auditCreated = true;
        } catch (auditError) {
          console.error('Failed to save audit data:', auditError);
        }
      } else {
        console.log('Audit record already exists for this item:', existingAudit.id);
        savedAudit = existingAudit;
        auditCreated = true;
      }
    }
    
    // Update the schedule with new items
    const updatedSchedule = {
      ...daySchedule,
      items: daySchedule.items
    };

    // Save schedule to API
    const savedSchedule = await saveSchedule(department, updatedSchedule);
    console.log('Schedule saved to database:', savedSchedule);
    
    // Update local state with the saved schedule from the database
    if (isNewScheduleDay) {
      setSchedules(prevSchedules => [...prevSchedules, savedSchedule]);
    } else {
      setSchedules(prevSchedules => prevSchedules.map(s => s.id === daySchedule.id ? savedSchedule : s));
    }
    
    // Emit events for other components to react
    bus.emit('schedule-updated', savedSchedule);
    bus.emit('data-updated', { type: 'schedule', data: savedSchedule });
    
    // Update calendar events
    const recipe = recipes.find(r => r.product_code === recipeCode);
    const [startHours, startMinutes] = startTime.split(':').map(Number);
    const [endHours, endMinutes] = endTime.split(':').map(Number);
    
    const startDate = new Date(date);
    startDate.setHours(startHours, startMinutes, 0);
    
    const endDate = new Date(date);
    endDate.setHours(endHours, endMinutes, 0);
    
    // Set the event color based on simplified status flow
    let eventColor = accentColor;
    if (newItem.status === 'planned') eventColor = theme.palette.info.main;
    else if (newItem.status === 'scheduled') eventColor = theme.palette.warning.main;
    else if (newItem.status === 'completed') eventColor = theme.palette.success.main;
    else if (newItem.status === 'cancelled') eventColor = theme.palette.error.main;
    
    const newEvent = {
      id: newItem.id,
      title: `${newItem.productDescription || recipe?.description || recipeCode} (${plannedQty})`,
      start: startDate,
      end: endDate,
      backgroundColor: eventColor,
      borderColor: eventColor,
      textColor: theme.palette.getContrastText(eventColor),
      extendedProps: {
        scheduleId: updatedSchedule.id,
        itemIndex: existingItemIndex !== -1 ? existingItemIndex : updatedSchedule.items.length - 1,
        recipeCode,
        plannedQty,
        handlerName: itemHandler,
        status: newItem.status,
        auditId: auditCreated && savedAudit ? savedAudit.id : null
      }
    };
    
    // Update the calendar events state immediately
    if (currentEventInfo) {
      // Replace the existing event
      setCalendarEvents(prevEvents => 
        prevEvents.map(event => event.id === newEvent.id ? newEvent : event)
      );
    } else {
      // Add the new event
      setCalendarEvents(prevEvents => [...prevEvents, newEvent]);
    }
    
    // Force immediate calendar refresh to ensure the event is displayed
    if (calendarRef.current) {
      const calendarApi = calendarRef.current.getApi();
      
      // Directly update the calendar's internal event source
      const eventSources = calendarApi.getEventSources();
      if (eventSources.length > 0) {
        eventSources[0].remove();
      }
      
      // Get the current events state
      let currentEvents = [...calendarEvents];
      
      // Update or add the new event
      if (currentEventInfo) {
        currentEvents = currentEvents.map(event => 
          event.id === newEvent.id ? newEvent : event
        );
      } else {
        currentEvents.push(newEvent);
      }
      
      // Add the updated events directly to the calendar
      calendarApi.addEventSource(currentEvents);
      
      // If this was triggered by a drag-and-drop, make sure to keep the view centered on the event
      if (startDate) {
        // Only change the date if we're not already showing the right week/day
        const currentViewStart = calendarApi.view.currentStart;
        const currentViewEnd = calendarApi.view.currentEnd;
        if (startDate < currentViewStart || startDate > currentViewEnd) {
          calendarApi.gotoDate(startDate);
        }
      }
    }
    
    // Show appropriate success message based on the action taken
    if (auditCreated) {
      console.log('Production completed and audit record created successfully');
      // Update the UI to reflect the completed status
      setNotification({
        open: true,
        message: 'Production completed and audit record created successfully',
        severity: 'success'
      });
    } else if (newItem.status === 'scheduled') {
      console.log('Production scheduled successfully');
      setNotification({
        open: true,
        message: 'Production scheduled successfully',
        severity: 'success'
      });
    } else if (newItem.status === 'planned') {
      console.log('Recipe planned successfully');
      setNotification({
        open: true,
        message: 'Recipe planned successfully',
        severity: 'success'
      });
    } else if (newItem.status === 'cancelled') {
      console.log('Recipe cancelled successfully');
      setNotification({
        open: true,
        message: 'Recipe cancelled successfully',
        severity: 'success'
      });
    }
    
    // Close the modal and reset state
    setUnifiedModalOpen(false);
    setCurrentEventInfo(null);
    setCurrentSlotInfo(null);
    setUnifiedModalItem(null);
  } catch (error) {
    console.error('Failed to save schedule:', error);
    setNotification({
      open: true,
      message: 'Failed to save schedule: ' + error.message,
      severity: 'error'
    });
  }
};

const renderEventContent = (eventInfo) => {
  const { event } = eventInfo;
  const { scheduleId, itemIndex, status } = event.extendedProps;
  
  // Define status icons
  const getStatusIcon = () => {
    switch(status) {
        case 'planned':
          return '📋'; // Clipboard icon
        case 'scheduled':
          return '🕒'; // Clock icon
        case 'completed':
          return '✅'; // Checkmark icon
        case 'cancelled':
          return '❌'; // X icon
        default:
          return '📋';
      }
    };
    
    // Define status badge style
    const getStatusBadgeStyle = () => {
      let bgColor;
      switch(status) {
        case 'planned':
          bgColor = theme.palette.info.light;
          break;
        case 'scheduled':
          bgColor = theme.palette.warning.light;
          break;
        case 'completed':
          bgColor = theme.palette.success.light;
          break;
        case 'cancelled':
          bgColor = theme.palette.error.light;
          break;
        default:
          bgColor = theme.palette.grey[500];
      }
      
      return {
        backgroundColor: bgColor,
        color: theme.palette.getContrastText(bgColor),
        padding: '2px 6px',
        borderRadius: '4px',
        fontSize: '0.7rem',
        fontWeight: 'bold',
        textTransform: 'uppercase',
        marginLeft: '4px',
        display: 'inline-block'
      };
    };
    
    return (
      <div style={{ overflow: 'hidden', textOverflow: 'ellipsis', position: 'relative' }}>
        <div style={{ display: 'flex', alignItems: 'center', marginBottom: '2px' }}>
          <b>{eventInfo.timeText}</b>
          <span style={getStatusBadgeStyle()}>{status}</span>
        </div>
        <div style={{ whiteSpace: 'nowrap', paddingRight: '24px', display: 'flex', alignItems: 'center' }}>
          <span style={{ marginRight: '4px' }}>{getStatusIcon()}</span>
          {event.title}
        </div>
        <div 
          style={{ 
            position: 'absolute', 
            right: 2, 
            top: 2, 
            cursor: 'pointer',
            fontSize: '0.75rem',
            padding: '2px',
            borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.7)',
            color: theme.palette.primary.main,
            width: '18px',
            height: '18px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontWeight: 'bold'
          }}
          onClick={(e) => handleViewHistory(e, scheduleId, itemIndex)}
          title="View change history"
        >
          H
        </div>
      </div>
    );
  };

  // Helper function to create audit data from production item
  const createAuditFromProductionData = (productionItem, recipe) => {
    const {
      recipeCode, plannedQty, actualQty, handlerName, date, status,
      qualityScore, notes, ingredientSuppliers, batchCodes,
      sellByDates, receivingDates, deviations, productDescription, managerName
    } = productionItem;
    
    // Prepare ingredient-related arrays
    const ingredientList = [];
    const supplierNames = [];
    const addressOfSupplier = [];
    const countryOfOrigin = [];
    const finalBatchCodes = [];
    const finalSellByDates = [];
    const finalReceivingDates = [];
    
    // Process ingredients if available
    if (recipe && recipe.ingredients && Array.isArray(recipe.ingredients)) {
      recipe.ingredients.forEach((ing, idx) => {
        // Calculate the quantity for this production run
        const baseQty = Number(ing.recipe_use) || 0;
        const totalQty = (baseQty * Number(plannedQty || 0)).toFixed(3);
        
        // Add ingredient to the list
        ingredientList.push(`${ing.description} (${totalQty} from base: ${baseQty})`);
        
        // Get supplier info
        const supplierName = ingredientSuppliers && ingredientSuppliers[idx] ? ingredientSuppliers[idx] : '';
        supplierNames.push(supplierName);
        
        // Add placeholder data for other fields
        addressOfSupplier.push('Supplier Address');
        countryOfOrigin.push('South Africa');
        
        // Use batch codes if available, or generate new ones
        const batchCode = batchCodes && batchCodes[idx] ? 
          batchCodes[idx] : 
          `BATCH-${recipeCode}-${idx + 1}-${Date.now().toString().slice(-6)}`;
        finalBatchCodes.push(batchCode);
        
        // Use sell-by dates if available, or generate new ones
        const sellByDate = sellByDates && sellByDates[idx] ? 
          sellByDates[idx] : 
          (() => {
            const date = new Date();
            date.setDate(date.getDate() + 7);
            return date.toISOString().split('T')[0];
          })();
        finalSellByDates.push(sellByDate);
        
        // Use receiving dates if available, or use today
        const receivingDate = receivingDates && receivingDates[idx] ? 
          receivingDates[idx] : 
          new Date().toISOString().split('T')[0];
        finalReceivingDates.push(receivingDate);
      });
    }
    
    // Create the audit data object
    const auditData = {
      id: Date.now(),
      uid: `${date}-${recipeCode}-${Date.now()}`,
      department: department,
      department_manager: managerName,
      food_handler_responsible: handlerName,
      packing_batch_code: ['test'], // Placeholder
      product_name: [recipe?.description || 'Unknown'],
      ingredient_list: ingredientList,
      supplier_name: supplierNames,
      address_of_supplier: addressOfSupplier,
      batch_code: finalBatchCodes,
      sell_by_date: finalSellByDates,
      receiving_date: finalReceivingDates,
      country_of_origin: countryOfOrigin,
      planned_qty: Number(plannedQty) || 0,
      actual_qty: Number(actualQty) || Number(plannedQty) || 0,
      notes: notes || '',
      quality_score: Number(qualityScore) || 1,
      deviations: deviations || ['none'],
      confirmation_timestamp: new Date().toISOString(),
      productDescription: productDescription || recipe?.description || recipeCode,
      date: date,
      status: status,
      originalScheduleId: productionItem.id,
      actualQty: Number(actualQty) || Number(plannedQty) || 0,
      qualityScore: Number(qualityScore) || 1,
      confirmationTimestamp: new Date().toISOString()
    };
    
    return auditData;
  };

  // eslint-disable-next-line no-unused-vars
  const handleUnifiedSave = async (data) => {
    try{
    // With the simplified status-based workflow, we use handleSaveTimeSlot for all operations
    // The function will handle the appropriate actions based on the current status
    const result = await handleSaveTimeSlot(data);
    const newItem = result || data; // Use the result from handleSaveTimeSlot or fall back to data
    const auditCreated = data.status === 'completed'; // Set auditCreated based on status
    
    // Show appropriate message based on status
    if (data.status === 'planned') {
      console.log('Recipe planned successfully');
    } else if (data.status === 'scheduled') {
      console.log('Production scheduled successfully');
    } else if (data.status === 'completed') {
      console.log('Production completed successfully');
    } else if (data.status === 'cancelled') {
      console.log('Recipe cancelled');
    }
    
    // Force a direct refresh of the calendar after saving
    if (calendarRef.current) {
      const calendarApi = calendarRef.current.getApi();
      
      // Directly update the calendar's internal event source
      const eventSources = calendarApi.getEventSources();
      if (eventSources.length > 0) {
        eventSources[0].remove();
      }
      
      // Get the current events state
      let currentEvents = [...calendarEvents];
      
      // Update or add the new event
      if (currentEventInfo) {
        currentEvents = currentEvents.map(event => 
          event.id === currentEventInfo.event.id ? currentEventInfo.event : event
        );
      } else if (currentEventInfo && currentEventInfo.event) {
        currentEvents.push(currentEventInfo.event);
      }
      
      // Add the updated events directly to the calendar
      calendarApi.addEventSource(currentEvents);
      
      // If this was triggered by a drag-and-drop, make sure to keep the view centered on the event
      if (startDate) {
        // Only change the date if we're not already showing the right week/day
        const currentViewStart = calendarApi.view.currentStart;
        const currentViewEnd = calendarApi.view.currentEnd;
        if (startDate < currentViewStart || startDate > currentViewEnd) {
          calendarApi.gotoDate(startDate);
        }
      }
    }
    
    // Show appropriate success message based on the action taken
    if (auditCreated) {
      console.log('Production completed and audit record created successfully');
      // Update the UI to reflect the completed status
      setNotification({
        open: true,
        message: 'Production completed and audit record created successfully',
        severity: 'success'
      });
    } else if (newItem.status === 'scheduled') {
      console.log('Production scheduled successfully');
      setNotification({
        open: true,
        message: 'Production scheduled successfully',
        severity: 'success'
      });
    } else if (newItem.status === 'planned') {
      console.log('Recipe planned successfully');
      setNotification({
        open: true,
        message: 'Recipe planned successfully',
        severity: 'success'
      });
    } else if (newItem.status === 'cancelled') {
      console.log('Recipe cancelled successfully');
      setNotification({
        open: true,
        message: 'Recipe cancelled successfully',
        severity: 'success'
      });
    }
    
    // Close the modal and reset state
    setUnifiedModalOpen(false);
    setCurrentEventInfo(null);
    setCurrentSlotInfo(null);
    setUnifiedModalItem(null);
  } catch (error) {
    console.error('Failed to save schedule:', error);
    setNotification({
      open: true,
      message: 'Failed to save schedule: ' + error.message,
      severity: 'error'
    });
  }
};

// Handle closing the notification
const handleCloseNotification = () => {
  setNotification(prev => ({ ...prev, open: false }));
};

return (
  <Box sx={{ flexGrow: 1, p: 3 }}>
    {/* Rest of the component JSX */}
    
    {/* Print Document Modal */}
    <PrintDocumentModal
      open={printModalOpen}
      onClose={() => setPrintModalOpen(false)}
      schedules={filteredSchedules || []}
      recipes={recipes || []}
    />
    
    {/* Notification Snackbar */}
    <Snackbar
      open={notification.open}
      autoHideDuration={6000}
      onClose={handleCloseNotification}
      anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
    >
      <Alert onClose={handleCloseNotification} severity={notification.severity}>
        {notification.message}
      </Alert>
    </Snackbar>
    
    {/* Change History Dialog */}
    <ChangeHistoryDialog
      open={historyDialogOpen}
      onClose={() => {
        setHistoryDialogOpen(false);
        setSelectedHistoryItem(null);
      }}
      item={selectedHistoryItem}
      accentColor={accentColor}
      />
      
      {/* View-only Details Dialog */}
      <Dialog 
        open={viewDetailsOpen} 
        onClose={() => {
          setViewDetailsOpen(false);
          setSelectedHistoryItem(null);
        }}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle sx={{ 
          borderBottom: `2px solid ${accentColor}`, 
          color: accentColor,
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }}>
          <Box>
            <Typography variant="h6">
              Scheduled Assignment Details
            </Typography>
            {selectedHistoryItem && (
              <Typography variant="subtitle2">
                {selectedHistoryItem.productDescription || 
                 recipes.find(r => r.product_code === selectedHistoryItem.recipeCode)?.description || 
                 selectedHistoryItem.recipeCode}
              </Typography>
            )}
          </Box>
          <Chip 
            label={selectedHistoryItem?.status || 'planned'}
            color={
              selectedHistoryItem?.status === 'completed' ? 'success' :
              selectedHistoryItem?.status === 'scheduled' ? 'warning' :
              selectedHistoryItem?.status === 'cancelled' ? 'error' : 'info'
            }
            size="small"
          />
        </DialogTitle>
        <DialogContent dividers>
          {selectedHistoryItem && (
            <Grid container spacing={3}>
              {/* Basic Information */}
              <Grid item xs={12} md={6}>
                <Card variant="outlined" sx={{ mb: 2 }}>
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      Basic Information
                    </Typography>
                    <Grid container spacing={2}>
                      <Grid item xs={6}>
                        <Typography variant="subtitle2" color="text.secondary">
                          Recipe Code
                        </Typography>
                        <Typography variant="body1">
                          {selectedHistoryItem.recipeCode}
                        </Typography>
                      </Grid>
                      <Grid item xs={6}>
                        <Typography variant="subtitle2" color="text.secondary">
                          Planned Quantity
                        </Typography>
                        <Typography variant="body1">
                          {selectedHistoryItem.plannedQty}
                        </Typography>
                      </Grid>
                      <Grid item xs={6}>
                        <Typography variant="subtitle2" color="text.secondary">
                          Food Handler
                        </Typography>
                        <Typography variant="body1">
                          {selectedHistoryItem.handlerName || 'Not assigned'}
                        </Typography>
                      </Grid>
                      <Grid item xs={6}>
                        <Typography variant="subtitle2" color="text.secondary">
                          Date
                        </Typography>
                        <Typography variant="body1">
                          {selectedHistoryItem.date}
                        </Typography>
                      </Grid>
                      <Grid item xs={6}>
                        <Typography variant="subtitle2" color="text.secondary">
                          Start Time
                        </Typography>
                        <Typography variant="body1">
                          {selectedHistoryItem.startTime}
                        </Typography>
                      </Grid>
                      <Grid item xs={6}>
                        <Typography variant="subtitle2" color="text.secondary">
                          End Time
                        </Typography>
                        <Typography variant="body1">
                          {selectedHistoryItem.endTime}
                        </Typography>
                      </Grid>
                    </Grid>
                  </CardContent>
                </Card>
              </Grid>
              
              {/* Production Information - only shown for scheduled/completed items */}
              {(selectedHistoryItem.status === 'scheduled' || selectedHistoryItem.status === 'completed') && (
                <Grid item xs={12} md={6}>
                  <Card variant="outlined" sx={{ mb: 2 }}>
                    <CardContent>
                      <Typography variant="h6" gutterBottom>
                        Production Information
                      </Typography>
                      <Grid container spacing={2}>
                        <Grid item xs={6}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Actual Quantity
                          </Typography>
                          <Typography variant="body1">
                            {selectedHistoryItem.actualQty || selectedHistoryItem.plannedQty}
                          </Typography>
                        </Grid>
                        <Grid item xs={6}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Quality Score
                          </Typography>
                          <Typography variant="body1">
                            {selectedHistoryItem.qualityScore || 'N/A'}
                          </Typography>
                        </Grid>
                        <Grid item xs={12}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Notes
                          </Typography>
                          <Typography variant="body1">
                            {selectedHistoryItem.notes || 'No notes'}
                          </Typography>
                        </Grid>
                      </Grid>
                    </CardContent>
                  </Card>
                </Grid>
              )}
              
              {/* Change History */}
              <Grid item xs={12}>
                <Card variant="outlined">
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      Change History
                    </Typography>
                    {selectedHistoryItem.changeHistory && selectedHistoryItem.changeHistory.length > 0 ? (
                      <TableContainer>
                        <Table size="small">
                          <TableHead>
                            <TableRow>
                              <TableCell>Timestamp</TableCell>
                              <TableCell>Changed By</TableCell>
                              <TableCell>Changes</TableCell>
                            </TableRow>
                          </TableHead>
                          <TableBody>
                            {selectedHistoryItem.changeHistory.map((change, index) => (
                              <TableRow key={index}>
                                <TableCell>{new Date(change.timestamp).toLocaleString()}</TableCell>
                                <TableCell>{change.changedBy}</TableCell>
                                <TableCell>
                                  {change.changes.map((c, i) => (
                                    <Box key={i} sx={{ mb: 0.5 }}>
                                      <Typography variant="body2">
                                        <strong>{c.field}:</strong> {c.oldValue !== null ? c.oldValue : '(none)'} → {c.newValue}
                                      </Typography>
                                    </Box>
                                  ))}
                                </TableCell>
                              </TableRow>
                            ))}
                          </TableBody>
                        </Table>
                      </TableContainer>
                    ) : (
                      <Typography variant="body2">No change history available</Typography>
                    )}
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          )}
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => {
              setViewDetailsOpen(false);
              setSelectedHistoryItem(null);
            }}
          >
            Close
          </Button>
          <Button
            variant="outlined"
            color="primary"
            onClick={() => {
              setViewDetailsOpen(false);
              setHistoryDialogOpen(true);
            }}
          >
            View Full History
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Export Schedule Modal */}
      {exportModalOpen && (
        <ExportScheduleModal
          open={exportModalOpen}
          onClose={() => setExportModalOpen(false)}
          schedules={schedules}
          recipes={recipes}
          department={department}
        />
      )}
      
      {/* Confirm Production Modal has been replaced by UnifiedScheduleModal */}
      <Dialog open={editModalOpen} onClose={() => setEditModalOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle sx={{ borderBottom: `2px solid ${accentColor}`, color: accentColor }}>
          Edit Production Document
        </DialogTitle>
        <DialogContent dividers>
          {selectedItem && selectedSchedule && (
            <Grid container spacing={2}>
              <Grid item xs={12}>
                <FormControl fullWidth margin="normal">
                  <InputLabel>Recipe</InputLabel>
                  <Select
                    value={selectedItem.recipeCode}
                    label="Recipe"
                    onChange={(e) => setSelectedItem({...selectedItem, recipeCode: e.target.value})}
                  >
                    {recipes.map((recipe) => (
                      <MenuItem key={recipe.product_code} value={recipe.product_code}>
                        {recipe.description}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12}>
                <TextField
                  label="Quantity"
                  type="number"
                  fullWidth
                  margin="normal"
                  value={selectedItem.plannedQty}
                  onChange={(e) => setSelectedItem({...selectedItem, plannedQty: Number(e.target.value)})}
                  InputProps={{ inputProps: { min: 1 } }}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  label="Start Time"
                  type="time"
                  fullWidth
                  margin="normal"
                  value={selectedItem.startTime || ''}
                  onChange={(e) => setSelectedItem({...selectedItem, startTime: e.target.value})}
                  InputLabelProps={{ shrink: true }}
                />
              </Grid>
              <Grid item xs={12} sm={6}>
                <TextField
                  label="End Time"
                  type="time"
                  fullWidth
                  margin="normal"
                  value={selectedItem.endTime || ''}
                  onChange={(e) => setSelectedItem({...selectedItem, endTime: e.target.value})}
                  InputLabelProps={{ shrink: true }}
                />
              </Grid>
              <Grid item xs={12}>
                <FormControl fullWidth margin="normal">
                  <InputLabel>Handler</InputLabel>
                  <Select
                    value={selectedItem.handlerName || selectedSchedule.handlersNames || ''}
                    label="Handler"
                    onChange={(e) => setSelectedItem({...selectedItem, handlerName: e.target.value})}
                  >
                    {handlers.map((handler) => (
                      <MenuItem key={handler.id || handler.name} value={handler.name}>
                        {handler.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
          )}
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => setEditModalOpen(false)}
            sx={{ color: theme.palette.text.secondary }}
          >
            Cancel
          </Button>
          <Button 
            variant="contained"
            onClick={() => handleSaveEdit(selectedItem)}
            sx={{ bgcolor: accentColor, '&:hover': { bgcolor: alpha(accentColor, 0.8) } }}
          >
            Save Changes
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Delete Confirmation Dialog */}
      <Dialog open={deleteConfirmOpen} onClose={() => setDeleteConfirmOpen(false)}>
        <DialogTitle>Confirm Delete</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete this production document?
            {selectedItem && selectedSchedule && (
              <Box component="span" sx={{ display: 'block', mt: 1, fontWeight: 'bold' }}>
                {(recipes.find(r => r.product_code === selectedItem.recipeCode) || {}).description || selectedItem.recipeCode}
                {' - '}
                {selectedSchedule.weekStartDate}
              </Box>
            )}
            This action cannot be undone.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteConfirmOpen(false)}>
            Cancel
          </Button>
          <Button 
            onClick={handleConfirmDelete} 
            color="error" 
            variant="contained"
          >
            Delete
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Day View Dialog - Shows all events for a specific day or time range */}
      <Dialog
        open={dayViewOpen}
        onClose={() => {
          setDayViewOpen(false);
          setDayEventsData(null);
        }}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle sx={{ 
          borderBottom: `2px solid ${accentColor}`, 
          color: accentColor 
        }}>
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h6">
              {dayEventsData?.startTime && dayEventsData?.endTime
                ? `Scheduled Events (${dayEventsData.startTime} - ${dayEventsData.endTime})`
                : `Scheduled Events for ${dayEventsData?.date}`}
            </Typography>
            <Chip 
              label={`${dayEventsData?.events?.length || 0} Events`}
              color="primary"
              size="small"
            />
          </Box>
        </DialogTitle>
        <DialogContent dividers>
          {dayEventsData?.events?.length > 0 ? (
            <>
              <Typography variant="subtitle2" gutterBottom color="text.secondary">
                Click on any event to view its details
              </Typography>
              <Grid container spacing={2} sx={{ mt: 1 }}>
                {dayEventsData.events.map((event, index) => {
                  const { status } = event.extendedProps;
                  const statusColor = 
                    status === 'completed' ? theme.palette.success.light :
                    status === 'scheduled' ? theme.palette.warning.light :
                    status === 'cancelled' ? theme.palette.error.light : theme.palette.info.light;
                  
                  return (
                    <Grid item xs={12} sm={6} key={index}>
                      <Card 
                        variant="outlined" 
                        sx={{ 
                          cursor: 'pointer',
                          '&:hover': { boxShadow: 2 },
                          borderLeft: `4px solid ${statusColor}`
                        }}
                        onClick={() => {
                          // Find the schedule and item for detailed view
                          const { scheduleId, itemIndex } = event.extendedProps;
                          const schedule = schedules.find(s => s.id === scheduleId);
                          
                          if (schedule && schedule.items && schedule.items[itemIndex]) {
                            const item = schedule.items[itemIndex];
                            setSelectedHistoryItem(item);
                            setDayViewOpen(false);
                            setViewDetailsOpen(true);
                          }
                        }}
                      >
                        <CardContent sx={{ pb: 1 }}>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                            <Typography variant="subtitle1" noWrap sx={{ fontWeight: 'bold', maxWidth: '70%' }}>
                              {event.title}
                            </Typography>
                            <Chip 
                              label={status || 'planned'}
                              size="small"
                              sx={{ 
                                bgcolor: statusColor,
                                color: theme.palette.getContrastText(statusColor)
                              }}
                            />
                          </Box>
                          
                          <Grid container spacing={1}>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="text.secondary">
                                Time:
                              </Typography>
                              <Typography variant="body2">
                                {new Date(event.start).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - 
                                {new Date(event.end).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                              </Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="text.secondary">
                                Handler:
                              </Typography>
                              <Typography variant="body2" noWrap>
                                {(() => {
                                  // Find the actual schedule item to get the correct handler name
                                  const { scheduleId, itemIndex } = event.extendedProps;
                                  const schedule = schedules.find(s => s.id === scheduleId);
                                  if (schedule && schedule.items && schedule.items[itemIndex]) {
                                    return schedule.items[itemIndex].handler || event.extendedProps.handlerName || 'Not assigned';
                                  }
                                  return event.extendedProps.handlerName || 'Not assigned';
                                })()}
                              </Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="text.secondary">
                                Planned Qty:
                              </Typography>
                              <Typography variant="body2">
                                {event.extendedProps.plannedQty}
                              </Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="text.secondary">
                                Recipe Code:
                              </Typography>
                              <Typography variant="body2">
                                {event.extendedProps.recipeCode}
                              </Typography>
                            </Grid>
                          </Grid>
                        </CardContent>
                        <CardActions sx={{ pt: 0 }}>
                          <Button size="small" color="primary">
                            View Details
                          </Button>
                        </CardActions>
                      </Card>
                    </Grid>
                  );
                })}
              </Grid>
            </>
          ) : (
            <Box sx={{ textAlign: 'center', py: 4 }}>
              <Typography variant="h6" color="text.secondary">
                No scheduled events found for this time period
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Try selecting a different day or time range
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={() => {
              setDayViewOpen(false);
              setDayEventsData(null);
            }}
          >
            Close
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default CreateProductionDocumentPage;
